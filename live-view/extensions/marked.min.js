/*
 * marked 4.0.12
 */

import{Lexer}from"./Lexer.js";import{Parser}from"./Parser.js";import{Tokenizer}from"./Tokenizer.js";import{Renderer}from"./Renderer.js";import{TextRenderer}from"./TextRenderer.js";import{Slugger}from"./Slugger.js";import{merge,checkSanitizeDeprecation,escape}from"./helpers.js";import{getDefaults,changeDefaults,defaults}from"./defaults.js";export function marked(e,r,t){if(null==e)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");if("function"==typeof r&&(t=r,r=null),r=merge({},marked.defaults,r||{}),checkSanitizeDeprecation(r),t){const n=r.highlight;let s;try{s=Lexer.lex(e,r)}catch(e){return t(e)}const o=function(e){let o;if(!e)try{r.walkTokens&&marked.walkTokens(s,r.walkTokens),o=Parser.parse(s,r)}catch(r){e=r}return r.highlight=n,e?t(e):t(null,o)};if(!n||n.length<3)return o();if(delete r.highlight,!s.length)return o();let a=0;return marked.walkTokens(s,(function(e){"code"===e.type&&(a++,setTimeout((()=>{n(e.text,e.lang,(function(r,t){if(r)return o(r);null!=t&&t!==e.text&&(e.text=t,e.escaped=!0),a--,0===a&&o()}))}),0))})),void(0===a&&o())}try{const t=Lexer.lex(e,r);return r.walkTokens&&marked.walkTokens(t,r.walkTokens),Parser.parse(t,r)}catch(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",r.silent)return"<p>An error occurred:</p><pre>"+escape(e.message+"",!0)+"</pre>";throw e}}marked.options=marked.setOptions=function(e){return merge(marked.defaults,e),changeDefaults(marked.defaults),marked},marked.getDefaults=getDefaults,marked.defaults=defaults,marked.use=function(...e){const r=merge({},...e),t=marked.defaults.extensions||{renderers:{},childTokens:{}};let n;e.forEach((e=>{if(e.extensions&&(n=!0,e.extensions.forEach((e=>{if(!e.name)throw new Error("extension name required");if(e.renderer){const r=t.renderers?t.renderers[e.name]:null;t.renderers[e.name]=r?function(...t){let n=e.renderer.apply(this,t);return!1===n&&(n=r.apply(this,t)),n}:e.renderer}if(e.tokenizer){if(!e.level||"block"!==e.level&&"inline"!==e.level)throw new Error("extension level must be 'block' or 'inline'");t[e.level]?t[e.level].unshift(e.tokenizer):t[e.level]=[e.tokenizer],e.start&&("block"===e.level?t.startBlock?t.startBlock.push(e.start):t.startBlock=[e.start]:"inline"===e.level&&(t.startInline?t.startInline.push(e.start):t.startInline=[e.start]))}e.childTokens&&(t.childTokens[e.name]=e.childTokens)}))),e.renderer){const t=marked.defaults.renderer||new Renderer;for(const r in e.renderer){const n=t[r];t[r]=(...s)=>{let o=e.renderer[r].apply(t,s);return!1===o&&(o=n.apply(t,s)),o}}r.renderer=t}if(e.tokenizer){const t=marked.defaults.tokenizer||new Tokenizer;for(const r in e.tokenizer){const n=t[r];t[r]=(...s)=>{let o=e.tokenizer[r].apply(t,s);return!1===o&&(o=n.apply(t,s)),o}}r.tokenizer=t}if(e.walkTokens){const t=marked.defaults.walkTokens;r.walkTokens=function(r){e.walkTokens.call(this,r),t&&t.call(this,r)}}n&&(r.extensions=t),marked.setOptions(r)}))},marked.walkTokens=function(e,r){for(const t of e)switch(r.call(marked,t),t.type){case"table":for(const e of t.header)marked.walkTokens(e.tokens,r);for(const e of t.rows)for(const t of e)marked.walkTokens(t.tokens,r);break;case"list":marked.walkTokens(t.items,r);break;default:marked.defaults.extensions&&marked.defaults.extensions.childTokens&&marked.defaults.extensions.childTokens[t.type]?marked.defaults.extensions.childTokens[t.type].forEach((function(e){marked.walkTokens(t[e],r)})):t.tokens&&marked.walkTokens(t.tokens,r)}},marked.parseInline=function(e,r){if(null==e)throw new Error("marked.parseInline(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked.parseInline(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");r=merge({},marked.defaults,r||{}),checkSanitizeDeprecation(r);try{const t=Lexer.lexInline(e,r);return r.walkTokens&&marked.walkTokens(t,r.walkTokens),Parser.parseInline(t,r)}catch(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",r.silent)return"<p>An error occurred:</p><pre>"+escape(e.message+"",!0)+"</pre>";throw e}},marked.Parser=Parser,marked.parser=Parser.parse,marked.Renderer=Renderer,marked.TextRenderer=TextRenderer,marked.Lexer=Lexer,marked.lexer=Lexer.lex,marked.Tokenizer=Tokenizer,marked.Slugger=Slugger,marked.parse=marked;export const options=marked.options;export const setOptions=marked.setOptions;export const use=marked.use;export const walkTokens=marked.walkTokens;export const parseInline=marked.parseInline;export const parse=marked;export const parser=Parser.parse;export const lexer=Lexer.lex;export{defaults,getDefaults}from"./defaults.js";export{Lexer}from"./Lexer.js";export{Parser}from"./Parser.js";export{Tokenizer}from"./Tokenizer.js";export{Renderer}from"./Renderer.js";export{TextRenderer}from"./TextRenderer.js";export{Slugger}from"./Slugger.js";
